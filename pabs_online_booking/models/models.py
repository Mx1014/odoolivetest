# -*- coding: utf-8 -*-

import calendar as cal
import random
import pytz
from datetime import datetime, timedelta, time
from dateutil import rrule
from dateutil.relativedelta import relativedelta
from babel.dates import format_datetime

from odoo import api, fields, models, _
from odoo.tools.misc import get_lang
from odoo.addons.base.models.res_partner import _tz_get
from odoo.addons.http_routing.models.ir_http import slug
from odoo.exceptions import ValidationError

class PlanCalendar(models.Model):
    _inherit = 'plan.calendar'

    def _slots_generate(self, first_day, last_day, timezone, x_business_line, type):
        """ Generate all appointment slots (in naive UTC, appointment timezone, and given (visitors) timezone)
            between first_day and last_day (datetimes in appointment timezone)

            :return: [ {'slot': slot_record, <timezone>: (date_start, date_end), ...},
                      ... ]
        """
        def append_slot(day, slot):
            local_start = appt_tz.localize(datetime.combine(day, time(hour=int(6.0), minute=int(round((6.0 % 1) * 60)))))
            local_end = appt_tz.localize(
                datetime.combine(day, time(hour=int(6.0), minute=int(round((6.0 % 1) * 60)))))
            slots.append({
                'Asia/Bahrain': (
                    local_start,
                    local_end,
                ),
                timezone: (
                    local_start.astimezone(requested_tz),
                    local_end.astimezone(requested_tz),
                ),
                'Asia/Bahrain': (
                    local_start.astimezone(pytz.UTC).replace(tzinfo=None),
                    local_end.astimezone(pytz.UTC).replace(tzinfo=None),
                ),
                'slot': slot,
            })
        appt_tz = pytz.timezone('Asia/Bahrain')
        requested_tz = pytz.timezone('Asia/Bahrain')

        slots = []
        date_to_start = 0
        if type == 'reserve':
            date_to_start = fields.Datetime.today() + timedelta(days=int(x_business_line.no_days))
        else:
            date_to_start = fields.Datetime.today()
        slot_ids = self.env['plan.calendar'].search([('status', '=', 'available'), ('start_datetime', '>', date_to_start), ('start_datetime', '<', last_day), ('business_line', '=', x_business_line.id)])
        # for slot in slot_ids.filtered(lambda x: int(x.start_datetime.isoweekday()) == first_day.isoweekday()):
        #     #if slot.hour > first_day.hour + first_day.minute / 60.0:
        #     append_slot(first_day.date(), slot)
        res = []
        fli = []
        for x in slot_ids:
            if x.start_datetime.date() not in res:
                res.append(x.start_datetime.date())
                fli.append(x.id)
        slot_weekday = [int(weekday.start_datetime.isoweekday()) - 1 for weekday in slot_ids]

        for day in rrule.rrule(rrule.DAILY,
                               dtstart=first_day.date() + timedelta(days=1),
                               until=last_day.date(),
                               byweekday=slot_weekday):
            for slot in slot_ids.filtered(lambda x: x.id in fli):
                append_slot(day, slot)

        return slots

    def _slots_available(self, slots, first_day, last_day, employee=None):
        """ Fills the slot stucture with an available employee

            :param slots: slots structure generated by _slots_generate
            :param first_day: start datetime in UTC
            :param last_day: end datetime in UTC
            :param employee: if set, only consider this employee
                             if not set, consider all employees assigned to this appointment type
        """

        def is_work_available(start_dt, end_dt, intervals):
            """ check if the slot is contained in the employee's work hours (defined by intervals)
            """
            def find_start_index():
                """ find the highest index of intervals for which the start_date (element [0]) is before (or at) start_dt
                """
                def recursive_find_index(lower_bound, upper_bound):
                    if upper_bound - lower_bound <= 1:
                        if intervals[upper_bound][0] <= start_dt:
                            return upper_bound
                        return lower_bound
                    index = (upper_bound + lower_bound) // 2
                    if intervals[index][0] <= start_dt:
                        return recursive_find_index(index, upper_bound)
                    else:
                        return recursive_find_index(lower_bound, index)

                if start_dt <= intervals[0][0] - tolerance:
                    return -1
                if end_dt >= intervals[-1][1] + tolerance:
                    return -1
                return recursive_find_index(0, len(intervals) - 1)

            if not intervals:
                return False

            tolerance = timedelta(minutes=1)
            start_index = find_start_index()
            if start_index != -1:
                for index in range(start_index, len(intervals)):
                    if intervals[index][1] >= end_dt - tolerance:
                        return True
                    if len(intervals) == index + 1 or intervals[index + 1][0] - intervals[index][1] > tolerance:
                        return False
            return False

        def is_calendar_available(slot, events, employee):
            """ Returns True if the given slot doesn't collide with given events for the employee
            """
            start_dt = slot['Asia/Bahrain'][0]
            end_dt = slot['Asia/Bahrain'][1]

            event_in_scope = lambda ev: (
                fields.Date.to_date(ev.start) <= fields.Date.to_date(end_dt)
                and fields.Date.to_date(ev.stop) >= fields.Date.to_date(start_dt)
            )

            for ev in events.filtered(event_in_scope):
                if ev.allday:
                    # allday events are considered to take the whole day in the related employee's timezone
                    event_tz = pytz.timezone('Asia/Bahrain')
                    ev_start_dt = datetime.combine(fields.Date.from_string(ev.start_date), time.min)
                    ev_stop_dt = datetime.combine(fields.Date.from_string(ev.stop_date), time.max)
                    ev_start_dt = event_tz.localize(ev_start_dt).astimezone(pytz.UTC).replace(tzinfo=None)
                    ev_stop_dt = event_tz.localize(ev_stop_dt).astimezone(pytz.UTC).replace(tzinfo=None)
                    if ev_start_dt < end_dt and ev_stop_dt > start_dt:
                        return False
                elif ev.start_datetime < end_dt and ev.stop_datetime > start_dt:
                    return False
            return True

        workhours = {}
        meetings = {}

        # With context will be used in resource.calendar to force the referential user
        # for work interval computing to the *user linked to the employee*
        # available_employees = [emp.with_context({'tz': emp.user_id.tz}) for emp in (employee or self.employee_ids)]
        # random.shuffle(available_employees)
        # for slot in slots:
        #     for emp_pos, emp in enumerate(available_employees):
        #         if emp_pos not in workhours:
        #             workhours[emp_pos] = [
        #                 (interval[0].astimezone(pytz.UTC).replace(tzinfo=None),
        #                  interval[1].astimezone(pytz.UTC).replace(tzinfo=None))
        #                 for interval in emp.resource_calendar_id._work_intervals(
        #                     first_day, last_day, resource=emp.resource_id,
        #                 )
        #             ]
        #
        #         if is_work_available(slot['UTC'][0], slot['UTC'][1], workhours[emp_pos]):
        #             if emp_pos not in meetings:
        #                 # note: no check is made on the attendee's status (accepted/declined/...)
        #                 meetings[emp_pos] = self.env['calendar.event'].search([
        #                     ('partner_ids.user_ids', '=', emp.user_id.id),
        #                     ('start', '<', fields.Datetime.to_string(last_day.replace(hour=23, minute=59, second=59))),
        #                     ('stop', '>', fields.Datetime.to_string(first_day.replace(hour=0, minute=0, second=0)))
        #                 ])
        #
        #             if is_calendar_available(slot, meetings[emp_pos], emp):
        #                 slot['employee_id'] = emp
        #                 break

    def _get_appointment_slots(self, timezone, x_business_line, type, employee=None):
        """ Fetch available slots to book an appointment
            :param timezone: timezone string e.g.: 'Europe/Brussels' or 'Etc/GMT+1'
            :param employee: if set will only check available slots for this employee
            :returns: list of dicts (1 per month) containing available slots per day per week.
                      complex structure used to simplify rendering of template
        """
        #self.ensure_one()
        appt_tz = pytz.timezone('Asia/Bahrain')
        requested_tz = pytz.timezone(timezone)
        first_day = requested_tz.fromutc(datetime.utcnow()) # relativedelta(hours=self.min_schedule_hours))
        last_day = requested_tz.fromutc(datetime.utcnow() + relativedelta(days=50))
        # Compute available slots (ordered)
        slots = self._slots_generate(first_day.astimezone(appt_tz), last_day.astimezone(appt_tz), timezone, x_business_line, type)
        # if not employee or employee:
        #     gett = self._slots_available(slots, first_day.astimezone(pytz.UTC), last_day.astimezone(pytz.UTC), employee)

        # Compute calendar rendering and inject available slots
        today = requested_tz.fromutc(datetime.utcnow())
        start = today
        month_dates_calendar = cal.Calendar(0).monthdatescalendar
        months = []
        while (start.year, start.month) <= (last_day.year, last_day.month):
            dates = month_dates_calendar(start.year, start.month)
            for week_index, week in enumerate(dates):
                for day_index, day in enumerate(week):
                    mute_cls = weekend_cls = today_cls = None
                    today_slots = []
                    if day.weekday() in (cal.SUNDAY, cal.SATURDAY):
                        weekend_cls = 'o_weekend'
                    if day == today.date() and day.month == today.month:
                        today_cls = 'o_today'
                    if day.month != start.month:
                        mute_cls = 'text-muted o_mute_day'
                    else:
                        # slots are ordered, so check all unprocessed slots from until > day
                        i = 0
                        while slots and (slots[0][timezone][0].date() <= day):
                            if (slots[0]['slot']['start_datetime'].date() == day):
                                vals = ['Morning', 'Afternoon', 'Any Time']
                                if i == 0:
                                    today_slots.append({
                                        # 'employee_id': 1, #None, slots[0]['employee_id'].id,
                                        'slot_id': slots[0]['slot'],
                                        'datetime': slots[0]['slot']['start_datetime'].strftime('%Y-%m-%d %H:%M:%S'),
                                        'hours': vals[0]  # slots[0][timezone][0].strftime('%H:%M')
                                    })
                                    today_slots.append({
                                        # 'employee_id': 1, #None, slots[0]['employee_id'].id,
                                        'slot_id': slots[0]['slot'],
                                        'datetime': slots[0]['slot']['start_datetime'].strftime('%Y-%m-%d %H:%M:%S'),
                                        'hours': vals[1]  # slots[0][timezone][0].strftime('%H:%M')
                                    })
                                    today_slots.append({
                                        # 'employee_id': 1, #None, slots[0]['employee_id'].id,
                                        'slot_id': slots[0]['slot'],
                                        'datetime': slots[0]['slot']['start_datetime'].strftime('%Y-%m-%d %H:%M:%S'),
                                        'hours': vals[2]  # slots[0][timezone][0].strftime('%H:%M')
                                    })
                                i += 1
                            slots.pop(0)

                    dates[week_index][day_index] = {
                        'day': day,
                        'slots': today_slots,
                        'mute_cls': mute_cls,
                        'weekend_cls': weekend_cls,
                        'today_cls': today_cls
                    }

            months.append({
                'month': format_datetime(start, 'MMMM Y', locale=get_lang(self.env).code),
                'weeks': dates
            })
            start = start + relativedelta(months=1)
        return months
